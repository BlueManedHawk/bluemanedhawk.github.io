<!DOCTYPE html>
<html>
	<head>
		<title>The Perfect Language | Blue-Maned_Hawk's Creations</title>
		<meta charset=utf8 />
		<link rel=stylesheet href=./main.css />
	</head>
	<body>
		<h1>The Perfect Language</h1>
		<span class=subtitle><i>An essay by Blue-Maned_Hawk</i></span>
		<p>
		<i>You can also obtain this essay <a href=./The_Perfect_Language.pdf>as a PDF</a>.</i>
		</p>
		<p>
		Within conlanging, the concept of a language designed for the maximum degree of precision and unambiguity is often called a “philosophical language”, or a “sophlang”.  I have absolutely no idea where this term comes from, as it is quite obviously a misnomer, since linguistics is a science and it seems like philosophy would only ambiguate a perfect language instead of making it less ambiguous.  Really, these languages probably need a name like “scientific language” instead, but in any case, the name doesn’t matter for this essay as long as you know what I’m talking about.
		</p>
		<p>
		There have been many attempts at creating such a language as this before, but while many of them have certainly come close to perfection (to various degrees), it seems that there’s never been one that nails perfection.  I’ll analyze some specific examples at the end of this essay, but first, I’d like to talk about what it seems would be required for a language to be perfect.
		</p>
		<p>
		One thing I’d like to discuss first is something strange I’ve noticed about what happens when people try to reduce ambiguity:  they try to figure out what specific words mean.  At first, this may seem reasonable, but this leads to arguments where people try to compact a nebulous concept into a pristine packet of precision, and inherently can’t due to a variety of problems they encounter, such as disagreement and failing to account for existing connotations of words.  This is a concept that I’ll refer back to multiple times throughout this essay.
		</p>
		<p>
		Another thing that I want to discuss is standardization.  In order for a perfect language to work, it must be formally standardized and maintained well to be updated to suit the speakers’ needs—without this, dialects, deviation, and weirdness will occur, completely destroying the point of the language.  Obviously, this makes the language totally unsuited for usage as a replacement for natural languages, instead relegating it to the realm of an auxiliary language.  However, it probably wouldn’t have replaced natural languages anyway, seeing as the level of precision it would allow wouldn’t be really necessary in a lot of circumstances, only being required for things like science or politics or just clearing up minor confusions.
		</p>
		<p>
		With all of that out of the way:  The first thing is that a perfect language must be based on semantic primes:  those concepts so core that they cannot possibly be defined any further (or would go in an infinite loop with no lower levels of definition) that are inherently universal in every language.  I have no idea what these are, and I’m not sure that anybody does.  There’s a page on Wikipedia, but I strongly disagree with the list it has there, as it lists multiple words that simply are not semantic primes:
		</p>
		<p>
		<ul>
			<li><b>Good</b> and <b>Bad</b>:  These are both extremely vague, nebulous terms that mean different things in different circumstances.  They can easily be replaced with things such as “achieves a clock speed of more than 1GHz” or “is at least this sour” or “stretches to at least this degree”, each of which can be further defined using semantic primes.</li>
			<li><b>People</b>, <b>Live</b>, <b>Die</b>, <b>Think</b>, <b>Know</b>, <b>Want</b>, <b>Body</b>, <b>Say</b>, <b>Words</b>, and <b>Is mine</b>:  These are all complicated things that can be very difficult to define. However, simply giving up on them and categorizing them as “you know it when you see it” things is very much the wrong course of action.  While it is inherently difficult, these concepts all certainly can be defined, although then you get back to the problem of assigning a meaning to a word instead of the other way around.</li>
			<li><b>Before</b> and <b>After</b>, <b>Above</b> and <b>Below</b>, and <b>Very</b> and<b> More</b>:  Only one of each of these pairs is necessary.  For the first two pairs, one can be described as the opposite of the other, and for the last, it’s simply that they both refer to the same thing.</li>
			<li><b>Much</b>, <b>Few</b>, <b>Big</b>, <b>Small</b>, <b>A long time</b>, <b>A short time</b>, <b>Far</b>, and <b>Near</b>: These can be replaced with certain ranges, depending upon the context.</li>
			<li><b>Feel</b>, <b>See</b>, <b>Hear</b>, and <b>Touch</b> <b>(contact</b>:<b>)</b> These can all be replaced by “observe”, augmented for the medium through which one is observing.</li>
			<li><b>Don’t want</b>:  A particularly egregious nonprime.  What’s stopping this as being defined as…well, to not want something?  Why is this considered a prime?</li>
			<li><b>Two</b>:  Two is one combined with another one.  Why is this considered a prime?</li>
		</ul>
		<br>
		In addition to the problem of there being too many words listed as primes, the list on Wikipedia simultaneously suffers from not having enough semantic primes.  In particular, it seems to be missing the concept of an “otherwise” (which, as all programmers know, is a necessary complement to the “if”).  There’s also the fact that the concepts of “for some time” and “moment” exist, but not the concepts of “area” and “point”—ideally, these would be the same pairs of words, augmented for “space” and “time” as necessary.
		</p>
		<p>
		Once the semantic primes have been determined, we then move onto the problem of how to make a language from them.  This mostly consists of determining which ones to be morphological and which ones to be lexical, along with other things like syntax, phonology, and script.  These are all implementation details that are largely arbitrary, so I’m going to ignore this, as I have my own opinions on these topics and I want this to stay fairly objective.
		</p>
		<p>
		Now that we have a language, it would be pretty impractical to have to break down everything to its most basic components, especially when you get to really complicated things like biology or industry or politics.  Obviously, certain things that people will be saying a lot would need to be lexicalized (and in exceptionally useful circumstances, maybe even morphologized!)  for the language to be useful.  However, it must not go overkill—otherwise, the result would be a bloated, difficult-to-learn language.  Careful design decisions, not just in the lexicon but also in the morphology, would need to be made so as to balance convenience with practicality.
		</p>
		<p>
		Once this is done and the language is being maintained, this is done.  We have a perfect language now.
		<hr/>
		</p>
		<p>
		To finish off this essay, I’d like to discuss some attempts that have been made to reach a language like this.  First off, there are a lot of conlangs that have been made where this isn’t the goal of the language.  And that’s perfectly fine!  This is a really difficult thing to make, as evidenced by the fact that no attempts so far have succeeded perfectly (although some have come to various levels of close).  Discussing these languages is outside of the scope of this essay, and besides, someone's already doing that.
		</p>
		<p>
		Let’s start off with Toki Pona, because I’ve heard not many, but still a significant amount, of claims that this language is about “reducing things to their most basic”, and people equating this with the idea of semantic primacy.  It really isn’t, as evidenced by the fact that a lot of words are not semantic primes, and more importantly, they aren’t even defined in terms of semantic primes.  It’s still a very cool language, though.
		</p>
		<p>
		Now, Lojban.  It’s often argued that this language is designed to perfectly reduce ambiguity.  However, it really only reduces the ambiguity of the relationships that nouns and verbs have to each other, and doesn’t reduce the ambiguity of what the nouns and verbs actually are.  It’s also certainly not based on the idea of semantic primes.
		</p>
		<p>
		Finally, Ithkuil. I really really like this language, but I can’t help but notice that, even through four revisions—Iţkuîl, Ilaksh, Elartkʰa, and Malëuţŗait—it still isn’t perfect.  The primary source of this is in the fact that many of its terms aren’t defined in terms of semantic primes—instead, they tend to be given vague definitions, often including phrases like “the general idea of”.  I believe that most of this stems from the fact that several parts of the language are, unfortunately, fairly deeply rooted in philosophy.  In any case, there’s clearly a lot of effort put into this language, and I don’t want to trouble its creator with any more.
		</p>
		<p>
		Thank you for reading this essay.  I hope that this was enlightening for you.
		</p>
		<p class=Footer><a href=../index.html>Main Page</a> | <a href=./index.html>Creations</a> | <a href=../Contact.html>Contact</a> | <a href=../Copyright.html>Copyright</a></p>
	</body>
</html>
